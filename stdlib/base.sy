mod base.dynarray

impl dynarray(element_type) {
  fn append_slot(self: &dynarray) {
  }

  fn assign(self: &dynarray) {
  }

  fn clear(self: &dynarray) {
  }

  fn compact(self: &dynarray) {
  }

  fn copy(self: &dynarray!, other: &dynarray!) {
    other.ensure_capacity(self.length)
    other.clear()
    for (i: 0..self.length) {
      other.set(i, self
    }
  }

  fn delete(self: &dynarray) {
  }

  fn delete_unordered(self: &dynarray) {
  }

  fn delete_until(self: &dynarray) {
  }

  fn ends_with(self: &dynarray) {
  }

  fn ensure_capacity(self: &dynarray) {
  }

  fn equals(self: &dynarray) {
  }

  fn find(self: &dynarray) {
  }

  fn find_index(self: &dynarray) {
  }

  # OK, these are magic methods.

  # fn index(self: &dynarray!, i: uint): IndexResult(element_type)
  # fn index_ref(self: &dynarray!, i: uint): IndexResult(&element_type)
  # fn index_ex(self: &dynarray!, i: uint): IndexResult(&element_type!)

  fn init(self: &dynarray) {
  }

  fn init_capacity(self: &dynarray) {
  }

  fn init_length(self: &dynarray) {
  }

  fn init_length_capacity(self: &dynarray) {
  }

  fn insert_slot(self: &dynarray) {
  }

  fn move_left(self: &dynarray) {
  }

  fn move_right(self: &dynarray) {
  }

  fn pop(self: &dynarray) {
  }

  fn pop_left(self: &dynarray) {
  }

  fn pop_right(self: &dynarray) {
  }

  fn pop_unordered(self: &dynarray) {
  }

  fn prepend_slot(self: &dynarray) {
  }

  fn replace(self: &dynarray) {
  }

  fn seek(self: &dynarray) {
  }

  fn set(self: &dynarray) {
  }

  fn set_capacity(self: &dynarray) {
  }

  fn set_length(self: &dynarray) {
  }

  fn skip(self: &dynarray) {
  }

  fn starts_with(self: &dynarray) {
  }

  fn truncate(self: &dynarray) {
  }

  fn zero(self: &dynarray) {
  }
}

mod base.string

alias string: dynarray(u8)

iface String {
  fn get_length(self: &String): uint
}

impl String(str) {
  fn get_length(self: &str): uint {
    return self::element_count
  }
}

impl String(string) {
  fn get_length(self: &string): uint {
    return self.length
  }
}

mod base.result

req sys

variant Result(ok_type) {
  OK: ok_type,
  Fail: String,
}

impl Result(ok_type) {
  fn on_failure(r: Result, handler: fn(s: Stringable)): ok_type {
    match (r) {
      case (value: OK) { return value }
      case (stringable: Fail) { handler(stringable) }
    }
  }

  fn ok_or_die(r: Result): ok_type {
    return
    match (r) {
      case (value: OK) { return value }
      case (stringable: Fail) { sys.die(stringable.to_string()) }
    }
  }
}

fn on_failure(ok_type) (
  r: Result(ok_type),
  handler: fntype(s: Stringable)
): Result(ok_type, failed_type) {
  match (r) {
    case (stringable: Fail) { handler(stringable) }
    default {}
  }

  return r
}

fn ok_or_die(ok_type) (
  r: Result(ok_type)
): ok_type {
  match (r) {
    case (value: OK) { return success }
    case (stringable: Fail) { sys.die(stringable.to_string()) }
  }
}
