mod poker

req random

range Score 1u8..10u8

range Value 1u8..14u8

range DeckSize 0u8..52u8

variant RankVariant {
  Single: {
    name: str,
    score: Score,
    value: Value,
  },
  Double: {
    name: str,
    score1: Score,
    score2: Score,
    value1: Value,
    value2: Value,
  }
}

enum Rank {
  Ace:   RankVariant.Double{"Ace",   Score(1), Score(10), Value(1), Value(14)},
  Two:   RankVariant.Single{"Two",   Score(2),            Value(2)},
  Three: RankVariant.Single{"Three", Score(3),            Value(3)},
  Four:  RankVariant.Single{"Four",  Score(4),            Value(4)},
  Five:  RankVariant.Single{"Five",  Score(5),            Value(5)},
  Six:   RankVariant.Single{"Six",   Score(6),            Value(6)},
  Seven: RankVariant.Single{"Seven", Score(7),            Value(7)},
  Eight: RankVariant.Single{"Eight", Score(8),            Value(8)},
  Nine:  RankVariant.Single{"Nine",  Score(9),            Value(9)},
  Ten:   RankVariant.Single{"Ten",   Score(10),           Value(10)},
  Jack:  RankVariant.Single{"Jack",  Score(10),           Value(11)},
  Queen: RankVariant.Single{"Queen", Score(10),           Value(12)},
  King:  RankVariant.Single{"King",  Score(10),           Value(13)},
}

enum Suit {
  Spade:   0u8,
  Club:    1u8,
  Diamond: 2u8,
  Heart:   3u8,
}

struct CardStruct {
  suit: Suit,
  rank: Rank
}

enum Cards {
  AceOfSpades:     CardStruct{Suit.Spade,   Rank.Ace},
  TwofSpades:      CardStruct{Suit.Spade,   Rank.Two},
  ThreeOfSpades:   CardStruct{Suit.Spade,   Rank.Three},
  FourOfSpades:    CardStruct{Suit.Spade,   Rank.Four},
  FiveOfSpades:    CardStruct{Suit.Spade,   Rank.Five},
  SixOfSpades:     CardStruct{Suit.Spade,   Rank.Six},
  SevenOfSpades:   CardStruct{Suit.Spade,   Rank.Seven},
  EightOfSpades:   CardStruct{Suit.Spade,   Rank.Eight},
  NineOfSpades:    CardStruct{Suit.Spade,   Rank.Nine},
  TenOfSpades:     CardStruct{Suit.Spade,   Rank.Ten},
  JackOfSpades:    CardStruct{Suit.Spade,   Rank.Jack},
  QueenOfSpades:   CardStruct{Suit.Spade,   Rank.Queen},
  KingOfSpades:    CardStruct{Suit.Spade,   Rank.King},
  AceOfClubs:      CardStruct{Suit.Club,    Rank.Ace},
  TwoOfClubs:      CardStruct{Suit.Club,    Rank.Two},
  ThreeOfClubs:    CardStruct{Suit.Club,    Rank.Three},
  FourOfClubs:     CardStruct{Suit.Club,    Rank.Four},
  FiveOfClubs:     CardStruct{Suit.Club,    Rank.Five},
  SixOfClubs:      CardStruct{Suit.Club,    Rank.Six},
  SevenOfClubs:    CardStruct{Suit.Club,    Rank.Seven},
  EightOfClubs:    CardStruct{Suit.Club,    Rank.Eight},
  NineOfClubs:     CardStruct{Suit.Club,    Rank.Nine},
  TenOfClubs:      CardStruct{Suit.Club,    Rank.Ten},
  JackOfClubs:     CardStruct{Suit.Club,    Rank.Jack},
  QueenOfClubs:    CardStruct{Suit.Club,    Rank.Queen},
  KingOfClubs:     CardStruct{Suit.Club,    Rank.King},
  AceOfHearts:     CardStruct{Suit.Heart,   Rank.Ace},
  TwoOfHearts:     CardStruct{Suit.Heart,   Rank.Two},
  ThreeOfHearts:   CardStruct{Suit.Heart,   Rank.Three},
  FourOfHearts:    CardStruct{Suit.Heart,   Rank.Four},
  FiveOfHearts:    CardStruct{Suit.Heart,   Rank.Five},
  SixOfHearts:     CardStruct{Suit.Heart,   Rank.Six},
  SevenOfHearts:   CardStruct{Suit.Heart,   Rank.Seven},
  EightOfHearts:   CardStruct{Suit.Heart,   Rank.Eight},
  NineOfHearts:    CardStruct{Suit.Heart,   Rank.Nine},
  TenOfHearts:     CardStruct{Suit.Heart,   Rank.Ten},
  JackOfHearts:    CardStruct{Suit.Heart,   Rank.Jack},
  QueenOfHearts:   CardStruct{Suit.Heart,   Rank.Queen},
  KingOfHearts:    CardStruct{Suit.Heart,   Rank.King},
  AceOfDiamonds:   CardStruct{Suit.Diamond, Rank.Ace},
  TwoOfDiamonds:   CardStruct{Suit.Diamond, Rank.Two},
  ThreeOfDiamonds: CardStruct{Suit.Diamond, Rank.Three},
  FourOfDiamonds:  CardStruct{Suit.Diamond, Rank.Four},
  FiveOfDiamonds:  CardStruct{Suit.Diamond, Rank.Five},
  SixOfDiamonds:   CardStruct{Suit.Diamond, Rank.Six},
  SevenOfDiamonds: CardStruct{Suit.Diamond, Rank.Seven},
  EightOfDiamonds: CardStruct{Suit.Diamond, Rank.Eight},
  NineOfDiamonds:  CardStruct{Suit.Diamond, Rank.Nine},
  TenOfDiamonds:   CardStruct{Suit.Diamond, Rank.Ten},
  JackOfDiamonds:  CardStruct{Suit.Diamond, Rank.Jack},
  QueenOfDiamonds: CardStruct{Suit.Diamond, Rank.Queen},
  KingOfDiamonds:  CardStruct{Suit.Diamond, Rank.King},
}

alias Deck: [*Card * DeckSize::count]

alias Hand: [&Card * 5]

alias DealResult: Result(&Card, str)

fntype rank_value_comparer(value1: Value, value2: RankValue): bool

fn rank_value_less_than(value1: Value, value2: RankValue): bool {
  return value1 < value2
}

fn rank_value_greater_than(value1: Value, value2: RankValue): bool {
  return value1 > value2
}

fn rank_value_equal(value1: Value, value2: RankValue): bool {
  return value1 == value2
}

fn rank_value_precedes(value1: Value, value2: RankValue): bool {
  return value1 == value2 - 1
}

fn rank_value_succeeds(value1: Value, value2: RankValue): bool {
  return (value1 == (value2 + 1))
}

fn compare_ranks(cmp: rank_value_comparer, r1: &Rank, r2: &rank): bool {
  match (r1) {
    case (s1: Single) {
      match (r2) {
        case (s2: Single) {
          return cmp(s1.value, s2.value)
        }
        case (d2: Double) {
          return cmp(s1.value, d2.value1) || cmp(s1.value, d2.value2)
        }
      }
    }
    case (d1: Double) {
      match (other) {
        case (s2: Single) {
          return cmp(d1.value1, s2.value) || cmp(d1.value2, s2.value)
        }
        case (d2: Double) {
          return (
            cmp(d1.value1, d2.value1) || cmp(d1.value1, d2.value2) ||
            cmp(d1.value2, d2.value1) || cmp(d1.value2, d2.value2)
          )
        }
      }
    }
  }
}

fn rank_less_than(rank: &rank, other: &rank): bool {
  return compare_ranks(rank_value_less_than, rank, other)
}

fn rank_greater_than(rank: &rank, other: &rank): bool {
  return compare_ranks(rank_value_greater_than, rank, other)
}

fn rank_equals(rank: &rank, other: &rank): bool {
  return compare_ranks(rank_value_equals, rank, other)
}

fn rank_precedes(rank: &rank, other: &rank): bool {
  return compare_ranks(rank_value_precedes, rank, other)
}

fn rank_succeeds(rank: &rank, other: &rank): bool {
  return compare_ranks(rank_value_succeeds, rank, other)
}

fn card_less_than(card: &Card, other: &Card): bool {
  return (
    card.suit < other.suit ||
    (card.suit == other.suit && card.rank < other.rank)
  )
}

fn card_greater_than(card: &Card, other: &Card): bool {
  return (
    card.suit > other.suit ||
    (card.suit == other.suit && card.rank > other.rank)
  )
}

fn card_equals(card: &Card, other: &Card): bool {
  return card.suit == other.suit && card.rank == other.rank
}

fn shuffle_deck(deck: &Deck!) {
  random.shuffle(&Deck)(deck)
}

fn deal_from_deck(deck: &Deck!): DealResult {
  let res: deck.pop(0)

  match (res) {
    case (*card: OK) {
      return DealResult.OK(*card)
    }
    default {
      return DealResult.Fail("No more cards")
    }
  }
}

fn build_hand(hand: &Hand!, deck: &Deck!, count: DeckSize) {
  for (i: Hand::indices) {
    let res: deal_from_deck(deck)

    match (res) {
      case (*card: OK) {
        hand[i] = *card
      }
      default {
        break
      }
    }
  }

  array_sort(&Hand!)(&hand!) # [TODO] Is `array_sort` a function? Probably not
}

fn hand_remove_card_at_index(hand: &Hand!, index: uint) {
  array_delete(&hand.cards!, index)
}

fn hand_get_card_at_index(hand: &Hand!, index: uint): &Card {
  return hand.cards.get(index).succeed_or_die()
}

fn get_value_counts(hand: &Hand, counts: [uint * Value::max]) {
  for (&card: hand.cards) {
    match (card.rank) {
      case (s: Single) {
        value_counts[s.value]++
      }
      case (d: Double) {
        value_counts[d.value1]++
      }
    }
  }
}

fn hand_is_pair(hand: &Hand): bool {
  let value_counts: [uint(0) * Value::max]
  let pair_count: 0u

  hand.get_value_counts(&value_counts!)

  for (count: value_counts) {
    pair_count += count % 2u
  }

  return pair_count > 1u
}

fn hand_is_two_pair(hand: &Hand): bool {
  let value_counts: [uint(0) * Value::max]
  let pair_count: 0u

  hand.get_value_counts(&value_counts!)

  for (count: value_counts) {
    pair_count += count % 2u
  }

  return pair_count > 2u
}

fn hand_is_three_of_a_kind(hand: &Hand): bool {
  let value_counts: [uint(0) * Value::max]
  let trip_count: 0u

  hand.get_value_counts(&value_counts!)

  for (count: value_counts) {
    trip_count += count % 3u
  }

  return trip_count > 1u
}

fn hand_is_four_of_a_kind(hand: &Hand): bool {
  let value_counts: [uint(0) * Value::max]
  let quad_count: 0u

  hand.get_value_counts(&value_counts!)

  for (count: value_counts) {
    quad_count += count % 4u
  }
}

fn hand_is_flush(hand: &Hand): bool {
  let initialized: false
  let last_card: &Cards.AceOfSpades

  for (&card: hand.cards) {
    if (!initialized) {
      initialized = true
    }
    else if (card.suit != last_card.suit) {
      return false
    }

    last_card = card
  }

  return true
}

fn hand_is_straight(hand: &Hand): bool {
  let initialized: false
  let last_card: &Cards.AceOfSpaces

  for (&card: hand.cards) {
    if (!initialized) {
      initialized = true
    }
    else if (!card.succeeds(last_card)) {
      return false
    }

    last_card = &card
  }

  return true
}
